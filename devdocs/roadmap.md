# Lockplane Roadmap

This roadmap is organized around the 8 major production pain points teams face when managing Postgres schemas while shipping fast. Each section explains the problem, how Lockplane addresses it today, and what's planned.

## The 8 Big Problems in Production Postgres Schema Management

### 1. Backward-Compatible Changes (Expand/Contract Pattern)

**The Problem:**
You can't do "one big DDL + code deploy" in prod. You need multi-step, backward-compatible changes: add new column, backfill, dual-write, flip reads, then drop old stuff. This is evolutionary database design—treat schema changes as incremental, reversible steps, not big-bang redesigns.

**How Lockplane Helps Today:**
- **Declarative schema** naturally supports expand/contract: define your target state, generate the minimal migration
- **Shadow DB validation** catches breaking changes before they hit prod
- **Automatic rollback generation** for every forward migration gives you a safety net

**Roadmap:**
- [ ] **Multi-step migration planning** - Detect operations that require expand/contract and generate the full sequence (e.g., "add nullable column" → "backfill" → "add NOT NULL constraint")
- [ ] **Compatibility checker** - Analyze schema changes and flag operations that break backward compatibility with running application versions
- [ ] **Migration tags** - Label migrations with app version compatibility ranges to coordinate deployments

### 2. Avoiding Locks and Downtime During DDL

**The Problem:**
Many Postgres DDL operations take heavyweight locks that block reads/writes or get blocked by long transactions. A "simple" ALTER TABLE can stall your whole app. Postgres-specific mitigations (CREATE INDEX CONCURRENTLY, lock_timeout, NOT VALID constraints) reduce this but add complexity.

**How Lockplane Helps Today:**
- **Validation reports** warn about potentially dangerous operations
- **Shadow DB testing** lets you measure lock duration and impact before prod

**Roadmap:**
- [ ] **Lock-safe DDL rewriting** - Automatically rewrite dangerous operations into safe patterns:
  - `CREATE INDEX` → `CREATE INDEX CONCURRENTLY`
  - `ADD COLUMN NOT NULL DEFAULT` → two-step with NOT VALID + VALIDATE
  - `ALTER COLUMN TYPE` → expand/contract with new column + trigger
- [ ] **Lock timeout configuration** - Inject `SET lock_timeout` for DDL statements
- [ ] **Operation timing estimates** - Measure DDL duration on shadow DB and report expected lock times
- [ ] **Batched operations** - Break large index builds or constraint validations into smaller chunks

### 3. Large Data Migrations & Backfills

**The Problem:**
Schema changes require moving or transforming data: backfilling new columns, splitting/merging tables, normalizing blobs. Doing this online requires chunked/batched updates, background workers, and careful management of transaction size, vacuum, and index bloat.

**How Lockplane Helps Today:**
- **Shadow DB validation** lets you test backfill performance on realistic data before prod
- **Explicit migration plans** show exactly what SQL will run

**Roadmap:**
- [ ] **Batched backfill generation** - For data-heavy operations, generate chunked UPDATE statements with progress tracking:
  ```sql
  -- Generated by Lockplane
  UPDATE users SET email_normalized = LOWER(email)
  WHERE id >= $1 AND id < $2
  AND email_normalized IS NULL;
  ```
- [ ] **Backfill estimator** - Calculate expected duration based on shadow DB row counts and statistics
- [ ] **Progress tracking** - Monitor backfill progress, resume from checkpoints on failure
- [ ] **Vacuum & bloat management** - Automatically insert VACUUM/ANALYZE commands after large updates

### 4. Rollbacks Are Hard (Stateful System, Irreversible Changes)

**The Problem:**
DB changes aren't trivially reversible once new data has been written in the "new" shape (dropped columns, destructive transforms). Blue-green/shadow DB strategies exist precisely because safe in-place rollback is non-trivial.

**How Lockplane Helps Today:**
- **Automatic rollback generation** for every forward migration
- **Shadow DB testing** provides a safe environment to validate both forward and rollback before prod

**Roadmap:**
- [ ] **Rollback safety analysis** - Flag migrations where rollback would be lossy or dangerous:
  - "⚠️ Rollback drops column `new_status` with data written after migration"
  - "✅ Rollback is safe: only removes empty column"
- [ ] **Blue-green migration mode** - Generate plans for parallel schema deployment:
  1. Deploy new schema alongside old
  2. Dual-write to both
  3. Validate new schema
  4. Cutover reads
  5. Remove old schema
- [ ] **Point-in-time recovery guides** - Document when PITR is safer than in-place rollback

### 5. Schema Drift Between Environments

**The Problem:**
Hotfixes in prod, manual psql changes, and inconsistent migration runs across dev/stage/prod cause drift. Debugging and reproducing issues becomes painful. Multi-env/multi-project setups make this worse.

**How Lockplane Helps Today:**
- **Introspection + diff** detects drift: compare your desired schema to any environment
- **Declarative source of truth** (desired.json) eliminates "which migration did we run where?" confusion
- **Environment-specific configs** in lockplane.toml keep credentials and URLs organized

**Roadmap:**
- [ ] **Drift detection CI workflow** - GitHub Action that runs `lockplane plan` on each environment and flags drift
- [ ] **Schema fingerprinting** - Hash schema state for quick drift detection across environments
- [ ] **Drift reconciliation** - Generate fix-up migrations to bring drifted environments back to desired state
- [ ] **Read-only mode** - Prevent manual changes by using restricted DB roles during normal operations
- [ ] **Audit log** - Track all schema changes with who/when/why metadata

### 6. Catching Dangerous Migrations Before They Hit Prod

**The Problem:**
Dropping/renaming columns, changing types, adding NOT NULL with defaults, or running heavy UPDATE/DELETE can all be dangerous in production. It's easy to shoot yourself in the foot. Libraries like Strong Migrations exist solely to detect and block unsafe operations.

**How Lockplane Helps Today:**
- **Validation reports** flag risky operations with explanations
- **Shadow DB testing** catches issues before they reach prod
- **Explicit migration plans** force you to review SQL before applying

**Roadmap:**
- [ ] **Safety levels** - Configurable risk tolerance:
  - `strict`: Block all potentially dangerous operations
  - `moderate`: Warn but allow with confirmation (default)
  - `permissive`: Log warnings only
- [ ] **Dangerous operation detection**:
  - DROP COLUMN / DROP TABLE without expand/contract
  - ALTER COLUMN TYPE requiring table rewrite
  - ADD CONSTRAINT without NOT VALID
  - Backfills without batching on large tables
  - Index creation without CONCURRENTLY
- [ ] **Impact estimation** - Report "this will lock table X for ~30s based on shadow DB timing"
- [ ] **Required review annotations** - Force explicit approval comments for dangerous operations

### 7. Testing Migrations Realistically (Prod-Like Data + CI)

**The Problem:**
Migrations pass in CI but fail or degrade performance on real prod datasets due to data volume, skew, or pathological rows/constraints. You need automated tests, continuous integration, and dev sandboxes with realistic data snapshots.

**How Lockplane Helps Today:**
- **Shadow DB testing** - Test every migration on a prod-like database before applying to prod
- **Environment isolation** - Each environment (dev/stage/prod) has its own config and shadow DB
- **Validation reports** surface issues early

**Roadmap:**
- [ ] **CI integration guides** - Documented patterns for GitHub Actions, GitLab CI, CircleCI
- [ ] **Schema test fixtures** - Generate test data that exercises edge cases (nullable columns, large text, Unicode, etc.)
- [ ] **Performance regression detection** - Compare query plans and timing before/after migration on shadow DB
- [ ] **Prod snapshot automation** - Tools to safely copy prod schema + anonymized sample data to staging
- [ ] **Load testing mode** - Run migrations under simulated production load to measure impact

### 8. Cross-Team / Cross-Service Coordination and Ownership

**The Problem:**
In microservices or multi-team environments, many apps/ETL jobs/reporting systems depend on the same Postgres schema. Coordinating breaking changes and deprecations across them is socially and operationally hard. This is a cultural and coordination challenge, not just technical.

**How Lockplane Helps Today:**
- **Declarative schema** serves as a shared source of truth for all teams
- **Migration plans** are reviewable artifacts that can be shared in PRs
- **Explicit descriptions** for each operation explain *why* the change is being made

**Roadmap:**
- [ ] **Schema ownership annotations** - Document which team/service owns which tables:
  ```json
  {
    "tables": [
      {
        "name": "users",
        "owner": "auth-team",
        "consumers": ["api-service", "analytics-etl"]
      }
    ]
  }
  ```
- [ ] **Breaking change notifications** - Detect schema changes that affect downstream consumers and generate alerts
- [ ] **Deprecation timelines** - Mark columns/tables as deprecated with removal dates:
  ```json
  {
    "name": "legacy_status",
    "deprecated": true,
    "removal_date": "2025-03-01",
    "replacement": "status_v2"
  }
  ```
- [ ] **Consumer impact analysis** - Scan application code/queries to identify which services will break
- [ ] **Migration dependencies** - Express "service A must deploy before we can run migration B"
- [ ] **Changelog generation** - Auto-generate human-readable schema change summaries for cross-team communication

---

## Additional Roadmap Items

### Database Support

**Current:** PostgreSQL, SQLite, libSQL

**Planned:**
- [ ] MySQL/MariaDB support
- [ ] CockroachDB support
- [ ] SQLite → Postgres migration path

### Migration Management

- [ ] **Migration history tracking** - Store applied migrations in DB (like rails_migrations table)
- [ ] **Idempotent migrations** - Safe to run multiple times
- [ ] **Partial migrations** - Apply only specific tables or operations
- [ ] **Migration squashing** - Combine many small migrations into one optimized migration

### Developer Experience

- [ ] **Interactive migration builder** - TUI for generating migrations step-by-step
- [ ] **Schema visualization** - Generate ERD diagrams from desired.json
- [ ] **Migration templates** - Common patterns (add column, split table, etc.)
- [ ] **Watch mode** - Auto-regenerate plans when desired.json changes

### Integration & Ecosystem

- [ ] **Prisma integration** - Import Prisma schema, export migrations
- [ ] **Alembic integration** - Import/export for Python projects
- [ ] **Supabase helpers** - First-class support for Supabase-specific features
- [ ] **Terraform provider** - Manage schemas as infrastructure
- [ ] **GitHub Actions** - Pre-built workflows for CI/CD

### Observability

- [ ] **Migration metrics** - Track success/failure rates, duration, rollback frequency
- [ ] **Schema health dashboard** - Visualize drift, migration status, risk levels across environments
- [ ] **Alerting integrations** - Slack/PagerDuty notifications for dangerous operations

### Gradual Adoption & Migration Tools

#### pgroll Integration & Adoption Path

[pgroll](https://github.com/xataio/pgroll) provides zero-downtime schema migrations with versioned schemas. Lockplane can complement pgroll and help teams adopt it gradually:

- [ ] **pgroll migration format export** - Convert Lockplane plans to pgroll migration format
  - Export `desired.json` diffs as pgroll-compatible JSON migrations
  - Map Lockplane operations to pgroll equivalents
  - Generate versioned schema definitions

- [ ] **Hybrid migration mode** - Run both traditional and pgroll migrations side-by-side:
  - Flag tables/schemas for pgroll management vs. traditional migrations
  - Generate migration plans that respect pgroll-managed schemas
  - Validate that changes don't conflict with pgroll versioning

- [ ] **pgroll adoption guide** - Documentation and tooling for migration path:
  - "Start with Lockplane, graduate to pgroll when you need zero-downtime"
  - Conversion examples showing equivalent Lockplane → pgroll patterns
  - Comparison matrix: when to use Lockplane vs. pgroll vs. both

- [ ] **Schema version tracking** - Support pgroll's versioned schema model:
  - Track which tables have multiple versions active
  - Generate queries that work across schema versions
  - Detect when old versions can be safely removed

**Why this matters:** Teams shouldn't have to rip-and-replace their migration workflow. Lockplane can be the on-ramp to more sophisticated tools like pgroll, providing value at each stage of maturity.

#### Database Version Upgrades

Help teams safely upgrade Postgres versions (e.g., 12 → 13 → 14 → 15 → 16):

- [ ] **Version compatibility checker** - Analyze schema for deprecated features:
  - Detect incompatible types, functions, or syntax across Postgres versions
  - Flag operations that behave differently in newer versions
  - Suggest rewrites for deprecated patterns

- [ ] **Upgrade validation workflow**:
  1. Introspect current schema on old Postgres version
  2. Test restore/migration on new Postgres version in shadow DB
  3. Compare query plans and performance
  4. Generate compatibility report

- [ ] **Pre-upgrade optimization** - Identify and fix issues before upgrading:
  - Find unused indexes (bloat) to drop before pg_upgrade
  - Detect tables that need VACUUM FULL
  - Identify slow queries that might get worse (or better) in new version

- [ ] **Extension compatibility** - Track extension version requirements:
  - PostGIS, pg_trgm, pgvector, timescaledb, etc.
  - Flag extensions that need updates before Postgres upgrade
  - Generate upgrade sequence: "upgrade extension X, then Postgres, then extension Y"

- [ ] **Post-upgrade tasks** - Generate checklist and automation:
  - ANALYZE all tables to rebuild statistics
  - Rebuild specific indexes that benefit from new version
  - Update query hints or configurations
  - Benchmark critical queries to verify performance

- [ ] **Blue-green upgrade orchestration** - Generate plans for zero-downtime upgrades:
  - Provision new Postgres version with pg_upgrade or logical replication
  - Validate schema and data consistency
  - Cutover sequence with rollback plan
  - Monitor replication lag and performance during migration

**Why this matters:** Major version upgrades are rare but high-risk. Teams often delay them due to complexity and fear of breaking changes. Automated validation and clear upgrade paths reduce that friction.

---

## Future: lockplane-auth

Define authentication rules once and target them to multiple data stores. `lockplane-auth` compiles a unified policy specification into row-level security policies for relational databases, Firestore security rules, or the closest equivalent that each supported database offers, ensuring consistent enforcement regardless of the underlying platform.

This extends Lockplane's philosophy of **write once, deploy everywhere** from schema management to security policies.

---

## Contributing

See issues tagged with `roadmap` in the GitHub issue tracker. If you have ideas or want to tackle any of these items, open an issue to discuss the approach first.

**Prioritization is driven by:**
1. Production pain points (the 8 areas above)
2. User requests and feedback
3. Safety and correctness over convenience
4. Real-world usage patterns

The goal is to make Postgres schema changes as safe and boring as deploying application code.
