package wizard

import (
	"fmt"
	"os"
	"strings"

	tea "github.com/charmbracelet/bubbletea"
)

type WizardState int

const (
	StateStart WizardState = iota
	StateCreateSucceeded
	StateCreateFailed
)

type wizardModel struct {
	state    WizardState
	finalErr error
	force    bool
	yes      bool
}

func initialModel(force bool, yes bool) wizardModel {
	return wizardModel{
		state: StateStart,
		force: force,
		yes:   yes,
	}
}

func (m wizardModel) Init() tea.Cmd {
	// If --yes flag is set, auto-execute immediately
	if m.yes {
		return writeDefaultInit(m.force)
	}
	return nil
}

// commands
type fileCreationResultMsg struct {
	err error
}

func writeDefaultInit(force bool) tea.Cmd {
	return func() tea.Msg {
		configPath := "lockplane.toml"
		schemaDir := "schema"

		if !force {
			if _, err := os.Stat(configPath); err == nil {
				return fileCreationResultMsg{err: fmt.Errorf("file lockplane.toml already exists. Use `lockplane init --force` to overwrite")}
			}
		}

		// Create schema directory
		if err := os.MkdirAll(schemaDir, 0755); err != nil {
			return fileCreationResultMsg{err: fmt.Errorf("failed to create schema directory: %w", err)}
		}

		// Check if schema directory is empty
		entries, err := os.ReadDir(schemaDir)
		if err != nil {
			return fileCreationResultMsg{err: fmt.Errorf("failed to read schema directory: %w", err)}
		}

		// Create example file if directory is empty
		if len(entries) == 0 {
			examplePath := schemaDir + "/example.lp.sql"
			exampleContent := `-- Example schema file
-- This creates a simple users table

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email TEXT NOT NULL UNIQUE,
    name TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);
`
			if err := os.WriteFile(examplePath, []byte(exampleContent), 0644); err != nil {
				return fileCreationResultMsg{err: fmt.Errorf("failed to create example file: %w", err)}
			}
		}

		var b strings.Builder
		b.WriteString("# Generated by: lockplane init\n")
		b.WriteString("#\n")
		b.WriteString("[environments.local]\n")
		b.WriteString("postgres_url = \"postgresql://postgres:postgres@localhost:5432/postgres\"\n")
		err = os.WriteFile(configPath, []byte(b.String()), 0600)
		return fileCreationResultMsg{err: err}
	}
}

// update
func (m wizardModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "enter":
			return m.handleEnter()
		default:
			return m, tea.Quit
		}
	case fileCreationResultMsg:
		switch msg.err {
		case nil:
			m.state = StateCreateSucceeded
		default:
			m.state = StateCreateFailed
			m.finalErr = msg.err
		}
		return m, tea.Quit
	}
	return m, nil
}

func (m wizardModel) handleEnter() (tea.Model, tea.Cmd) {
	switch m.state {
	case StateStart:
		return m, writeDefaultInit(m.force)
	}
	return m, nil
}

// render
func getResult(m wizardModel) (string, error) {
	switch m.state {
	case StateCreateFailed:
		return "Could not initialize lockplane", m.finalErr
	case StateCreateSucceeded:
		return "Created lockplane.toml and schema/ directory", nil
	default:
		return "", nil
	}
}

func (m wizardModel) View() string {
	switch m.state {
	case StateStart:
		return "Press Enter to create lockplane.toml and schema/ directory."
	default:
		res, _ := getResult(m)
		return res
	}
}

func Run(force bool, yes bool) error {
	// If --yes flag is set, bypass the TUI and execute immediately
	if yes {
		msg := writeDefaultInit(force)()
		resultMsg, ok := msg.(fileCreationResultMsg)
		if !ok {
			return fmt.Errorf("unexpected message type")
		}
		if resultMsg.err != nil {
			return resultMsg.err
		}
		res, err := getResult(wizardModel{state: StateCreateSucceeded})
		if res != "" {
			_, _ = fmt.Println(res)
		}
		return err
	}

	// Otherwise, run the interactive TUI
	p := tea.NewProgram(initialModel(force, yes))
	m, err := p.Run()
	if err != nil {
		return err
	}
	if wm, ok := m.(wizardModel); ok {
		res, err := getResult(wm)
		if res != "" {
			_, _ = fmt.Println(res)
		}
		return err
	} else {
		return fmt.Errorf("unexpected model type")
	}
}
