package wizard

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// GenerateFiles creates the lockplane.toml and .env files
func GenerateFiles(environments []EnvironmentInput) (*InitResult, error) {
	result := &InitResult{
		EnvFiles: []string{},
	}

	// Create schema directory if it doesn't exist
	schemaDir := "schema"
	if err := os.MkdirAll(schemaDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create schema directory: %w", err)
	}
	result.SchemaDir = schemaDir
	result.SchemaDirCreated = true

	// Generate lockplane.toml
	configPath := filepath.Join(schemaDir, "lockplane.toml")
	if err := generateLockplaneTOML(configPath, environments); err != nil {
		return nil, fmt.Errorf("failed to generate lockplane.toml: %w", err)
	}
	result.ConfigPath = configPath
	result.ConfigCreated = true

	// Generate .env files
	for _, env := range environments {
		envFilePath := fmt.Sprintf(".env.%s", env.Name)
		if err := generateEnvFile(envFilePath, env); err != nil {
			return nil, fmt.Errorf("failed to generate %s: %w", envFilePath, err)
		}
		result.EnvFiles = append(result.EnvFiles, envFilePath)
	}

	// Update .gitignore
	if err := updateGitignore(); err != nil {
		return nil, fmt.Errorf("failed to update .gitignore: %w", err)
	}
	result.GitignoreUpdated = true

	return result, nil
}

func generateLockplaneTOML(path string, environments []EnvironmentInput) error {
	var b strings.Builder

	b.WriteString("# Lockplane Configuration\n")
	b.WriteString("# Generated by: lockplane init\n")
	b.WriteString("#\n")
	b.WriteString("# Config location: Always in schema/ directory for consistency\n")
	b.WriteString("# Credentials: Stored in .env.* files (never in this file)\n\n")

	// Set default environment (use first one)
	if len(environments) > 0 {
		b.WriteString(fmt.Sprintf("default_environment = \"%s\"\n\n", environments[0].Name))
	}

	// Generate environment sections
	for _, env := range environments {
		b.WriteString(fmt.Sprintf("[environments.%s]\n", env.Name))

		// Description
		description := env.Description
		if description == "" {
			switch env.DatabaseType {
			case "postgres":
				description = "PostgreSQL database"
			case "sqlite":
				description = "SQLite database"
			case "libsql":
				description = "libSQL/Turso database"
			}
		}
		b.WriteString(fmt.Sprintf("description = \"%s\"\n", description))

		// Add comment about connection
		b.WriteString(fmt.Sprintf("# Connection: .env.%s\n", env.Name))

		// Add comment about shadow DB
		switch env.DatabaseType {
		case "postgres":
			b.WriteString("# Shadow DB: Auto-configured (safe migrations)\n")
		case "sqlite":
			b.WriteString("# Shadow DB: Disabled (avoids file clutter)\n")
		case "libsql":
			b.WriteString("# Shadow DB: Not supported\n")
		}

		b.WriteString("\n")
	}

	return os.WriteFile(path, []byte(b.String()), 0644)
}

func generateEnvFile(path string, env EnvironmentInput) error {
	var b strings.Builder

	b.WriteString(fmt.Sprintf("# Lockplane Environment: %s\n", env.Name))
	b.WriteString("# Generated by: lockplane init\n")
	b.WriteString("#\n")
	b.WriteString("# ⚠️  DO NOT COMMIT THIS FILE\n")
	b.WriteString("# (Already added to .gitignore automatically)\n\n")

	switch env.DatabaseType {
	case "postgres":
		connStr := BuildPostgresConnectionString(env)
		b.WriteString(fmt.Sprintf("# PostgreSQL connection (auto-detected sslmode=%s)\n", env.SSLMode))
		b.WriteString(fmt.Sprintf("DATABASE_URL=%s\n\n", connStr))

		shadowConnStr := BuildPostgresShadowConnectionString(env)
		b.WriteString("# Shadow database (always configured for PostgreSQL - safe migrations)\n")
		b.WriteString(fmt.Sprintf("SHADOW_DATABASE_URL=%s\n", shadowConnStr))

	case "sqlite":
		connStr := BuildSQLiteConnectionString(env)
		b.WriteString("# SQLite connection (file-based)\n")
		b.WriteString(fmt.Sprintf("DATABASE_URL=%s\n\n", connStr))
		b.WriteString("# Shadow database disabled for SQLite (avoids file clutter)\n")
		b.WriteString("# Migrations will run without shadow validation\n")

	case "libsql":
		connStr := BuildLibSQLConnectionString(env)
		b.WriteString("# libSQL/Turso connection\n")
		b.WriteString(fmt.Sprintf("DATABASE_URL=%s\n\n", connStr))
		b.WriteString("# Shadow database not supported by Turso\n")
	}

	// Write with restrictive permissions (owner read/write only)
	return os.WriteFile(path, []byte(b.String()), 0600)
}

func updateGitignore() error {
	gitignorePath := ".gitignore"

	// Read existing .gitignore if it exists
	content := ""
	if data, err := os.ReadFile(gitignorePath); err == nil {
		content = string(data)
	}

	// Check if .env.* pattern already exists
	if strings.Contains(content, ".env.*") || strings.Contains(content, ".env.") {
		// Already has the pattern, don't add again
		return nil
	}

	// Append the lockplane section
	lockplaneSection := `
# Lockplane environment files (added by lockplane init)
# DO NOT remove - contains database credentials
.env.*
!.env.*.example
`

	content += lockplaneSection

	return os.WriteFile(gitignorePath, []byte(content), 0644)
}
