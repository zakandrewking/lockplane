package wizard

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/pelletier/go-toml/v2"
)

// GenerateFiles creates the lockplane.toml and .env files
func GenerateFiles(environments []EnvironmentInput) (*InitResult, error) {
	result := &InitResult{
		EnvFiles: []string{},
	}

	// Create schema directory if it doesn't exist
	schemaDir := "schema"
	if err := os.MkdirAll(schemaDir, 0755); err != nil {
		return nil, fmt.Errorf("failed to create schema directory: %w", err)
	}
	result.SchemaDir = schemaDir
	result.SchemaDirCreated = true

	// Generate or update lockplane.toml
	configPath := filepath.Join(schemaDir, "lockplane.toml")
	fileExists := false
	if _, err := os.Stat(configPath); err == nil {
		fileExists = true
	}

	if err := generateLockplaneTOML(configPath, environments); err != nil {
		return nil, fmt.Errorf("failed to generate lockplane.toml: %w", err)
	}
	result.ConfigPath = configPath
	if fileExists {
		result.ConfigUpdated = true
	} else {
		result.ConfigCreated = true
	}

	// Generate .env files
	for _, env := range environments {
		envFilePath := fmt.Sprintf(".env.%s", env.Name)
		if err := generateEnvFile(envFilePath, env); err != nil {
			return nil, fmt.Errorf("failed to generate %s: %w", envFilePath, err)
		}
		result.EnvFiles = append(result.EnvFiles, envFilePath)
	}

	// Update .gitignore
	if err := updateGitignore(); err != nil {
		return nil, fmt.Errorf("failed to update .gitignore: %w", err)
	}
	result.GitignoreUpdated = true

	return result, nil
}

func generateLockplaneTOML(path string, newEnvironments []EnvironmentInput) error {
	// Load existing config if it exists
	existingEnvs := make(map[string]tomlEnvironment)
	var defaultEnv string

	if data, err := os.ReadFile(path); err == nil {
		// Parse existing config
		var existingConfig struct {
			DefaultEnvironment string                     `toml:"default_environment"`
			Environments       map[string]tomlEnvironment `toml:"environments"`
		}
		if err := toml.Unmarshal(data, &existingConfig); err == nil {
			existingEnvs = existingConfig.Environments
			defaultEnv = existingConfig.DefaultEnvironment
		}
	}

	// Merge new environments (new ones override existing with same name)
	for _, env := range newEnvironments {
		description := env.Description
		if description == "" {
			switch env.DatabaseType {
			case "postgres":
				description = "PostgreSQL database"
			case "sqlite":
				description = "SQLite database"
			case "libsql":
				description = "libSQL/Turso database"
			}
		}

		existingEnvs[env.Name] = tomlEnvironment{
			Description: description,
			Comment:     fmt.Sprintf("Connection: .env.%s", env.Name),
		}
	}

	// Set default environment if not already set
	if defaultEnv == "" && len(newEnvironments) > 0 {
		defaultEnv = newEnvironments[0].Name
	}

	// Build the TOML file
	var b strings.Builder

	b.WriteString("# Lockplane Configuration\n")
	b.WriteString("# Generated by: lockplane init\n")
	b.WriteString("#\n")
	b.WriteString("# Config location: Always in schema/ directory for consistency\n")
	b.WriteString("# Credentials: Stored in .env.* files (never in this file)\n\n")

	if defaultEnv != "" {
		b.WriteString(fmt.Sprintf("default_environment = \"%s\"\n\n", defaultEnv))
	}

	// Write all environment sections
	for envName, env := range existingEnvs {
		b.WriteString(fmt.Sprintf("[environments.%s]\n", envName))
		b.WriteString(fmt.Sprintf("description = \"%s\"\n", env.Description))
		b.WriteString(fmt.Sprintf("# %s\n", env.Comment))
		b.WriteString("\n")
	}

	return os.WriteFile(path, []byte(b.String()), 0644)
}

// tomlEnvironment represents an environment in the TOML file
type tomlEnvironment struct {
	Description string `toml:"description"`
	Comment     string `toml:"-"` // Not serialized, just for generation
}

func generateEnvFile(path string, env EnvironmentInput) error {
	var b strings.Builder

	b.WriteString(fmt.Sprintf("# Lockplane Environment: %s\n", env.Name))
	b.WriteString("# Generated by: lockplane init\n")
	b.WriteString("#\n")
	b.WriteString("# ⚠️  DO NOT COMMIT THIS FILE\n")
	b.WriteString("# (Already added to .gitignore automatically)\n\n")

	switch env.DatabaseType {
	case "postgres":
		connStr := BuildPostgresConnectionString(env)
		b.WriteString(fmt.Sprintf("# PostgreSQL connection (auto-detected sslmode=%s)\n", env.SSLMode))
		b.WriteString(fmt.Sprintf("DATABASE_URL=%s\n\n", connStr))

		shadowConnStr := BuildPostgresShadowConnectionString(env)
		b.WriteString("# Shadow database (always configured for PostgreSQL - safe migrations)\n")
		b.WriteString(fmt.Sprintf("SHADOW_DATABASE_URL=%s\n", shadowConnStr))

	case "sqlite":
		connStr := BuildSQLiteConnectionString(env)
		b.WriteString("# SQLite connection (file-based)\n")
		b.WriteString(fmt.Sprintf("DATABASE_URL=%s\n\n", connStr))
		b.WriteString("# Shadow database disabled for SQLite (avoids file clutter)\n")
		b.WriteString("# Migrations will run without shadow validation\n")

	case "libsql":
		connStr := BuildLibSQLConnectionString(env)
		b.WriteString("# libSQL/Turso connection\n")
		b.WriteString(fmt.Sprintf("DATABASE_URL=%s\n\n", connStr))
		b.WriteString("# Shadow database not supported by Turso\n")
	}

	// Write with restrictive permissions (owner read/write only)
	return os.WriteFile(path, []byte(b.String()), 0600)
}

func updateGitignore() error {
	gitignorePath := ".gitignore"

	// Read existing .gitignore if it exists
	content := ""
	if data, err := os.ReadFile(gitignorePath); err == nil {
		content = string(data)
	}

	// Check if .env.* pattern already exists
	if strings.Contains(content, ".env.*") || strings.Contains(content, ".env.") {
		// Already has the pattern, don't add again
		return nil
	}

	// Append the lockplane section
	lockplaneSection := `
# Lockplane environment files (added by lockplane init)
# DO NOT remove - contains database credentials
.env.*
!.env.*.example
`

	content += lockplaneSection

	return os.WriteFile(gitignorePath, []byte(content), 0644)
}
